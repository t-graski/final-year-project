sing backend.auth;
using backend.data;
using backend.dtos;
using backend.errors;
using backend.models;
using backend.models.@base;
using backend.services.interfaces;
using Microsoft.EntityFrameworkCore;

namespace backend.services.implementations;

public class UserService(AppDbContext db, ITokenService tokens, ICurrentUser currentUser) : IUserService
{
    public async Task<AuthResultDto> RegisterAsync(RegisterDto dto)
    {
        var email = dto.Email.Trim().ToLowerInvariant();

        var exists = await db.Users.AnyAsync(u => u.Email == email);
        if (exists)
        {
            throw new AppException(409, "EMAIL_EXISTS", "Email already exists.");
        }

        var hash = BCrypt.Net.BCrypt.HashPassword(dto.Password);

        var user = new User
        {
            Email = email,
            FirstName = dto.FirstName,
            LastName = dto.LastName,
            DateOfBirth = dto.DateOfBirth,
            PasswordHash = hash,
            IsActive = true,
            Permissions = (long)RolePermissions.ForRole(dto.Role)
        };

        db.Users.Add(user);

        var userRole = new UserRole
        {
            UserId = user.Id,
            Role = dto.Role
        };

        db.UserRoles.Add(userRole);

        switch (dto.Role)
        {
            case SystemRole.Student:
                var student = new Student
                {
                    UserId = user.Id,
                    StudentNumber = await GenerateStudentNumber()
                };

                db.Students.Add(student);
                break;
            case SystemRole.Staff:
            case SystemRole.Admin:
                var staff = new Staff
                {
                    UserId = user.Id,
                    StaffNumber = await GenerateStaffNumber(),
                    Department = "Unassigned"
                };

                db.Staff.Add(staff);
                break;
        }

        await db.SaveChangesAsync();

        var token = tokens.CreateAccessToken(user);
        return new AuthResultDto(user.Id, user.Email, user.FirstName, user.LastName, user.Permissions, token);
    }

    public async Task<AuthResultDto> LoginAsync(LoginDto dto)
    {
        var email = dto.Email.Trim().ToLowerInvariant();

        var user = await db.Users
            .Include(u => u.Roles)
            .FirstOrDefaultAsync(u => u.Email == email);
        if (user is null)
        {
            throw new AppException(401, "INVALID_CREDENTIALS", "Invalid email or password.");
        }

        if (!user.IsActive)
        {
            throw new AppException(403, "USER_DISABLED", "User is disabled.");
        }

        if (user.LockOutUntilUtc.HasValue && user.LockOutUntilUtc.Value > DateTimeOffset.UtcNow)
        {
            throw new AppException(403, "LOCKED_OUT", "User is temporarily locked out.");
        }

        var ok = BCrypt.Net.BCrypt.Verify(dto.Password, user.PasswordHash);

        if (!ok)
        {
            user.FailedLoginCount += 1;

            if (user.FailedLoginCount >= 5)
            {
                user.LockOutUntilUtc = DateTimeOffset.UtcNow.AddMinutes(10);
                user.FailedLoginCount = 0;
            }

            await db.SaveChangesAsync();
            throw new AppException(401, "INVALID_CREDENTIALS", "Invalid email or password");
        }

        user.FailedLoginCount = 0;
        user.LockOutUntilUtc = null;
        user.LastLoginAtUtc = DateTimeOffset.UtcNow;

        await db.SaveChangesAsync();

        var token = tokens.CreateAccessToken(user);
        return new AuthResultDto(user.Id, user.Email, user.FirstName, user.LastName, user.Permissions, token);
    }

    public async Task<UserDetailDto> GetMeAsync(Guid meId)
        => await GetByIdAsync(meId);

    public async Task<PagedDto<UserSummaryDto>> GetUsersAsync(int page, int pageSize)
    {
        page = page <= 0 ? 1 : page;
        pageSize = pageSize is < 1 or > 200 ? 25 : pageSize;

        var query = db.Users.AsNoTracking();
        var total = await query.LongCountAsync();

        var items = await query
            .OrderBy(u => u.Email)
            .Skip((page - 1) * pageSize)
            .Take(pageSize)
            .Select(u => new UserSummaryDto(
                u.Id,
                u.Email,
                u.FirstName,
                u.LastName,
                u.IsActive,
                u.Permissions,
                u.LastLoginAtUtc
            ))
            .ToListAsync();

        return new PagedDto<UserSummaryDto>(items, page, pageSize, total);
    }

    public async Task<UserDetailDto> GetByIdAsync(Guid userId)
    {
        var user = await db.Users.AsNoTracking()
            .Where(u => u.Id == userId)
            .Include(u => u.Roles)
            .ThenInclude(ur => ur.Role)
            .FirstOrDefaultAsync();

        if (user is null)
        {
            throw new AppException(404, "USER_NOT_FOUND", "User does not exist.");
        }

        return new UserDetailDto(
            user.Id,
            user.FirstName,
            user.LastName,
            user.Email,
            user.IsActive,
            user.Permissions,
            user.CreatedAtUtc,
            user.UpdatedAtUtc,
            user.Roles
        );
    }

    public Task<UserDetailDto> CreateAsync(CreateUserDto dto)
    {
        throw new NotImplementedException();
    }

    public async Task SetStatusAsync(Guid userId, bool isActive)
    {
        var user = await db.Users.FirstOrDefaultAsync(u => u.Id == userId);
        if (user is null)
        {
            throw new AppException(404, "USER_NOT_FOUND", "User does not exist.");
        }

        user.IsActive = isActive;
        await db.SaveChangesAsync();
    }

    public async Task SetPermissionsAsync(Guid userId, long permissions)
    {
        var user = await db.Users.FirstOrDefaultAsync(u => u.Id == userId);
        if (user is null)
        {
            throw new AppException(404, "USER_NOT_FOUND", "User does not exist.");
        }

        user.Permissions = permissions;
        await db.SaveChangesAsync();
    }

    public async Task AssignRoleAsync(Guid userId, SystemRole role)
    {
        var actorId = currentUser.UserId
                      ?? throw new AppException(401, "UNAUTHORIZED", "Authentication required.");

        var actor = await db.Users
            .Include(u => u.Roles)
            .FirstOrDefaultAsync(u => u.Id == actorId);

        if (actor is null)
        {
            throw new AppException(401, "ACTOR_NOT_FOUND", "Authentication user not found.");
        }

        var target = await db.Users
            .Include(u => u.Roles)
            .FirstOrDefaultAsync(u => u.Id == userId);

        if (target is null)
        {
            throw new AppException(404, "USER_NOT_FOUND", "Target user does not exist.");
        }

        var actorHighest = GetHighestActiveRole(actor);
        var targetHighest = GetHighestActiveRole(target);

        var actorHighestRank = actorHighest is null ? 0 : RoleHierarchy.Rank(actorHighest.Value);
        var targetHighestRank = targetHighest is null ? 0 : RoleHierarchy.Rank(targetHighest.Value);
        var newRoleRank = RoleHierarchy.Rank(role);

        var actorIsAdmin = actorHighest == SystemRole.Admin;

        // Rule #1: cannot modify someone higher than self
        if (targetHighestRank > actorHighestRank)
        {
            throw new AppException(403, "ROLE_TARGET_HIGHER",
                "You cannot modify a user with a higher role than yours.");
        }

        // Rule #2: cannot assign role higher than own highest role
        if (newRoleRank > actorHighestRank)
        {
            throw new AppException(403, "ROLE_ASSIGN_HIGHER_THAN_SELF",
                "You cannot assign a role higher than your own.");
        }

        // Rule #3: self can't give self a higher role
        if (actorId == userId && newRoleRank > actorHighestRank)
        {
            throw new AppException(403, "ROLE_SELF_PROMOTION", "You cannot assign yourself a higher role.");
        }

        // Rule #4: only admins can give same-level role
        if (newRoleRank == actorHighestRank && !actorIsAdmin)
        {
            throw new AppException(403, "ROLE_SAME_LEVEL_ADMIN_ONLY",
                "Only admins can assign a role at their own level.");
        }

        // Rule #5: admins can give other users admin
        if (roleEntity.Key == "admin" && !actorIsAdmin)
        {
            throw new AppException(403, "ROLE_ADMIN_REQUIRED", "Only admins can assign the admin role.");
        }

        var active = target.Roles.FirstOrDefault(r => r.RoleId == roleEntity.Id && !r.IsDeleted);
        if (active is not null)
        {
            return;
        }

        var deleted = target.Roles.FirstOrDefault(r => r.RoleId == roleEntity.Id && r.IsDeleted);

        if (deleted is not null)
        {
            deleted.IsDeleted = false;
            deleted.DeletedAtUtc = null;
            deleted.DeletedByUserId = null;
        }
        else
        {
            target.Roles.Add(new UserRole { UserId = userId, RoleId = roleEntity.Id });
        }

        target.Permissions = (long)ComputePermissionsFromRoles(target);

        await db.SaveChangesAsync();
    }

    public async Task RemoveRoleAsync(Guid userId, SystemRole role)
    {
        var actorId = currentUser.UserId
                      ?? throw new AppException(401, "UNAUTHORIZED", "Authentication required.");

        // Map SystemRole to role key
        var roleKey = role switch
        {
            SystemRole.Student => "student",
            SystemRole.Staff => "staff",
            SystemRole.Admin => "admin",
            _ => "student"
        };

        var roleEntity = await db.Roles.FirstOrDefaultAsync(r => r.Key == roleKey && !r.IsDeleted);
        if (roleEntity is null)
        {
            throw new AppException(404, "ROLE_NOT_FOUND", $"Role '{roleKey}' not found.");
        }

        var actor = await db.Users
            .Include(u => u.Roles)
            .ThenInclude(ur => ur.Role)
            .FirstOrDefaultAsync(u => u.Id == actorId);

        if (actor is null)
        {
            throw new AppException(401, "ACTOR_NOT_FOUND", "Authentication user not found.");
        }

        var target = await db.Users
            .Include(u => u.Roles)
            .ThenInclude(ur => ur.Role)
            .FirstOrDefaultAsync(u => u.Id == userId);

        if (target is null)
        {
            throw new AppException(404, "USER_NOT_FOUND", "Target user does not exist.");
        }

        var actorHighest = GetHighestActiveRole(actor);
        var targetHighest = GetHighestActiveRole(target);

        var actorHighestRank = actorHighest?.Rank ?? 0;
        var targetHighestRank = targetHighest?.Rank ?? 0;
        var removeRoleRank = roleEntity.Rank;

        var actorIsAdmin = actorHighest?.Key == "admin";

        // Rule #1: cannot modify someone higher than self
        if (targetHighestRank > actorHighestRank)
        {
            throw new AppException(403, "ROLE_TARGET_HIGHER",
                "You cannot modify a user with a higher role than yours.");
        }

        // Rule #2: cannot remove role higher than own highest role
        if (removeRoleRank > actorHighestRank)
        {
            throw new AppException(403, "ROLE_REMOVE_HIGHER_THAN_SELF",
                "You cannot remove a role higher than your own.");
        }

        // Rule #3: self can't remove self the highest role
        if (actorId == userId && targetHighest?.Id == roleEntity.Id)
        {
            throw new AppException(403, "ROLE_SELF_LOCKOUT", "You cannot remove your own highest role.");
        }

        if (roleEntity.Key == "admin" && !actorIsAdmin)
        {
            throw new AppException(403, "ROLE_ADMIN_REQUIRED", "Only admins can remove the admin role.");
        }

        if (roleEntity.Key == "admin")
        {
            var adminRole = await db.Roles.FirstAsync(r => r.Key == "admin");
            var adminCount = await db.UserRoles
                .Where(r => !r.IsDeleted && r.RoleId == adminRole.Id)
                .Select(r => r.UserId)
                .Distinct()
                .CountAsync();

            var targetIsAdmin = target.Roles.Any(r => r.IsDeleted == false && r.Role.Key == "admin");

            if (targetIsAdmin && adminCount <= 1)
            {
                throw new AppException(403, "ROLE_LAST_ADMIN", "You cannot remove the last admin.");
            }
        }

        var active = target.Roles.FirstOrDefault(r => r.RoleId == roleEntity.Id && !r.IsDeleted);
        if (active is null)
        {
            return;
        }

        active.IsDeleted = true;

        target.Permissions = (long)ComputePermissionsFromRoles(target);

        await db.SaveChangesAsync();
    }

    private static SystemRole? GetHighestActiveRole(User user)
    {
        var roles = user.Roles.Where(r => !r.IsDeleted).Select(r => r.Role);
        SystemRole? best = null;
        var bestRank = 0;

        foreach (var role in roles)
        {
            var rank = RoleHierarchy.Rank(role);
            if (rank > bestRank)
            {
                bestRank = rank;
                best = role;
            }
        }

        return best;
    }

    public static Permission ComputePermissionsFromRoles(User user)
    {
        var roles = user.Roles
            .Where(x => x is { IsDeleted: false, Role.IsDeleted: false })
            .Select(x => x.Role)
            .ToList();

        var effectivePerms = PermissionCalculator.ComputeEffective(roles);
        return (Permission)effectivePerms;
    }

    private async Task<string> GenerateStudentNumber()
    {
        var lastStudent = await db.Students
            .OrderByDescending(s => s.StudentNumber)
            .FirstOrDefaultAsync();

        if (lastStudent == null)
        {
            return "w1000001";
        }

        var lastNumber = int.Parse(lastStudent.StudentNumber[1..]);
        return $"w{lastNumber}";
    }

    private async Task<string> GenerateStaffNumber()
    {
        var lastStaff = await db.Staff
            .OrderByDescending(s => s.StaffNumber)
            .FirstOrDefaultAsync();

        if (lastStaff == null)
        {
            return "s1001";
        }

        var lastNumber = int.Parse(lastStaff.StaffNumber[1..]);
        return $"s{lastNumber + 1}";
    }
}